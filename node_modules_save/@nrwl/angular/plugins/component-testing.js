"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.nxComponentTestingPreset = void 0;
const cypress_preset_1 = require("@nrwl/cypress/plugins/cypress-preset");
const ct_helpers_1 = require("@nrwl/cypress/src/utils/ct-helpers");
const devkit_1 = require("@nrwl/devkit");
const runtime_lint_utils_1 = require("@nrwl/workspace/src/utils/runtime-lint-utils");
const fs_1 = require("fs");
const path_1 = require("path");
/**
 * Angular nx preset for Cypress Component Testing
 *
 * This preset contains the base configuration
 * for your component tests that nx recommends.
 * including a devServer that supports nx workspaces.
 * you can easily extend this within your cypress config via spreading the preset
 * @example
 * export default defineConfig({
 *   component: {
 *     ...nxComponentTestingPreset(__filename)
 *     // add your own config here
 *   }
 * })
 *
 * @param pathToConfig will be used for loading project options and to construct the output paths for videos and screenshots
 * @param options override options
 */
function nxComponentTestingPreset(pathToConfig, options) {
    var _a, _b, _c, _d;
    let graph;
    try {
        graph = (0, devkit_1.readCachedProjectGraph)();
    }
    catch (e) {
        throw new Error(
        // don't want to strip indents so error stack has correct indentation
        `Unable to read the project graph for component testing.
This is likely due to not running via nx. i.e. 'nx component-test my-project'.
Please open an issue if this error persists.
${e.stack ? e.stack : e}`);
    }
    const ctProjectConfig = (0, cypress_preset_1.getProjectConfigByPath)(graph, pathToConfig);
    const ctConfigurationName = process.env.NX_CYPRESS_TARGET_CONFIGURATION;
    const ctContext = (0, cypress_preset_1.createExecutorContext)(graph, ctProjectConfig.targets, ctProjectConfig.name, (options === null || options === void 0 ? void 0 : options.ctTargetName) || 'component-test', ctConfigurationName);
    const buildTarget = getBuildableTarget(ctContext);
    if (!buildTarget.project && !((_b = (_a = graph.nodes) === null || _a === void 0 ? void 0 : _a[buildTarget.project]) === null || _b === void 0 ? void 0 : _b.data)) {
        throw new Error((0, devkit_1.stripIndents) `Unable to find project configuration for build target. 
    Project Name? ${buildTarget.project}
    Has project config? ${!!((_d = (_c = graph.nodes) === null || _c === void 0 ? void 0 : _c[buildTarget.project]) === null || _d === void 0 ? void 0 : _d.data)}`);
    }
    const fromWorkspaceRoot = (0, path_1.relative)(devkit_1.workspaceRoot, pathToConfig);
    const normalizedFromWorkspaceRootPath = (0, fs_1.lstatSync)(pathToConfig).isFile()
        ? (0, path_1.dirname)(fromWorkspaceRoot)
        : fromWorkspaceRoot;
    const offset = (0, devkit_1.offsetFromRoot)(normalizedFromWorkspaceRootPath);
    const buildContext = (0, cypress_preset_1.createExecutorContext)(graph, graph.nodes[buildTarget.project].data.targets, buildTarget.project, buildTarget.target, buildTarget.configuration);
    const buildableProjectConfig = normalizeBuildTargetOptions(buildContext, ctContext, offset);
    return Object.assign(Object.assign({}, (0, cypress_preset_1.nxBaseCypressPreset)(pathToConfig)), { 
        // NOTE: cannot use a glob pattern since it will break cypress generated tsconfig.
        specPattern: ['**/*.cy.ts', '**/*.cy.js'], devServer: Object.assign(Object.assign({}, {
            framework: 'angular',
            bundler: 'webpack',
        }), { options: {
                projectConfig: buildableProjectConfig,
            } }) });
}
exports.nxComponentTestingPreset = nxComponentTestingPreset;
function getBuildableTarget(ctContext) {
    var _a;
    const targets = (_a = ctContext.projectGraph.nodes[ctContext.projectName].data) === null || _a === void 0 ? void 0 : _a.targets;
    const targetConfig = targets === null || targets === void 0 ? void 0 : targets[ctContext.targetName];
    if (!targetConfig) {
        throw new Error((0, devkit_1.stripIndents) `Unable to find component testing target configuration in project '${ctContext.projectName}'.
      Has targets? ${!!targets}
      Has target name? ${ctContext.targetName}
      Has ct project name? ${ctContext.projectName}
      `);
    }
    const cypressCtOptions = (0, devkit_1.readTargetOptions)({
        project: ctContext.projectName,
        target: ctContext.targetName,
        configuration: ctContext.configurationName,
    }, ctContext);
    if (!cypressCtOptions.devServerTarget) {
        throw new Error(`Unable to find the 'devServerTarget' executor option in the '${ctContext.targetName}' target of the '${ctContext.projectName}' project`);
    }
    return (0, devkit_1.parseTargetString)(cypressCtOptions.devServerTarget);
}
function normalizeBuildTargetOptions(buildContext, ctContext, offset) {
    const options = (0, devkit_1.readTargetOptions)({
        project: buildContext.projectName,
        target: buildContext.targetName,
        configuration: buildContext.configurationName,
    }, buildContext);
    const buildOptions = withSchemaDefaults(options);
    // paths need to be unix paths for angular devkit
    buildOptions.polyfills = (0, devkit_1.joinPathFragments)(offset, buildOptions.polyfills);
    buildOptions.main = (0, devkit_1.joinPathFragments)(offset, buildOptions.main);
    buildOptions.index =
        typeof buildOptions.index === 'string'
            ? (0, devkit_1.joinPathFragments)(offset, buildOptions.index)
            : Object.assign(Object.assign({}, buildOptions.index), { input: (0, devkit_1.joinPathFragments)(offset, buildOptions.index.input) });
    // cypress creates a tsconfig if one isn't preset
    // that contains all the support required for angular and component tests
    delete buildOptions.tsConfig;
    buildOptions.fileReplacements = buildOptions.fileReplacements.map((fr) => {
        fr.replace = (0, devkit_1.joinPathFragments)(offset, fr.replace);
        fr.with = (0, devkit_1.joinPathFragments)(offset, fr.with);
        return fr;
    });
    // if the ct project isn't being used in the build project
    // then we don't want to have the assets/scripts/styles be included to
    // prevent inclusion of unintended stuff like tailwind
    if ((0, ct_helpers_1.isCtProjectUsingBuildProject)(ctContext.projectGraph, buildContext.projectName, ctContext.projectName)) {
        buildOptions.assets = buildOptions.assets.map((asset) => {
            return typeof asset === 'string'
                ? (0, devkit_1.joinPathFragments)(offset, asset)
                : Object.assign(Object.assign({}, asset), { input: (0, devkit_1.joinPathFragments)(offset, asset.input) });
        });
        buildOptions.styles = buildOptions.styles.map((style) => {
            return typeof style === 'string'
                ? (0, devkit_1.joinPathFragments)(offset, style)
                : Object.assign(Object.assign({}, style), { input: (0, devkit_1.joinPathFragments)(offset, style.input) });
        });
        buildOptions.scripts = buildOptions.scripts.map((script) => {
            return typeof script === 'string'
                ? (0, devkit_1.joinPathFragments)(offset, script)
                : Object.assign(Object.assign({}, script), { input: (0, devkit_1.joinPathFragments)(offset, script.input) });
        });
    }
    else {
        const stylePath = getTempStylesForTailwind(ctContext);
        buildOptions.styles = stylePath ? [stylePath] : [];
        buildOptions.assets = [];
        buildOptions.scripts = [];
    }
    const { root, sourceRoot } = buildContext.projectGraph.nodes[buildContext.projectName].data;
    return {
        root: (0, devkit_1.joinPathFragments)(offset, root),
        sourceRoot: (0, devkit_1.joinPathFragments)(offset, sourceRoot),
        buildOptions,
    };
}
function withSchemaDefaults(options) {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
    if (!options.main) {
        throw new Error('Missing executor options "main"');
    }
    if (!options.index) {
        throw new Error('Missing executor options "index"');
    }
    if (!options.tsConfig) {
        throw new Error('Missing executor options "tsConfig"');
    }
    // cypress defaults aot to false so we cannot use buildOptimizer
    // otherwise the 'buildOptimizer' cannot be used without 'aot' error is thrown
    options.buildOptimizer = false;
    options.aot = false;
    (_a = options.assets) !== null && _a !== void 0 ? _a : (options.assets = []);
    (_b = options.allowedCommonJsDependencies) !== null && _b !== void 0 ? _b : (options.allowedCommonJsDependencies = []);
    (_c = options.budgets) !== null && _c !== void 0 ? _c : (options.budgets = []);
    (_d = options.commonChunk) !== null && _d !== void 0 ? _d : (options.commonChunk = true);
    (_e = options.crossOrigin) !== null && _e !== void 0 ? _e : (options.crossOrigin = 'none');
    (_f = options.deleteOutputPath) !== null && _f !== void 0 ? _f : (options.deleteOutputPath = true);
    (_g = options.extractLicenses) !== null && _g !== void 0 ? _g : (options.extractLicenses = true);
    (_h = options.fileReplacements) !== null && _h !== void 0 ? _h : (options.fileReplacements = []);
    (_j = options.inlineStyleLanguage) !== null && _j !== void 0 ? _j : (options.inlineStyleLanguage = 'css');
    (_k = options.i18nDuplicateTranslation) !== null && _k !== void 0 ? _k : (options.i18nDuplicateTranslation = 'warning');
    (_l = options.outputHashing) !== null && _l !== void 0 ? _l : (options.outputHashing = 'none');
    (_m = options.progress) !== null && _m !== void 0 ? _m : (options.progress = true);
    (_o = options.scripts) !== null && _o !== void 0 ? _o : (options.scripts = []);
    return options;
}
/**
 * @returns a path from the workspace root to a temp file containing the base tailwind setup
 * if tailwind is being used in the project root or workspace root
 * this file should get cleaned up via the cypress executor
 */
function getTempStylesForTailwind(ctExecutorContext) {
    const mappedGraph = (0, runtime_lint_utils_1.mapProjectGraphFiles)(ctExecutorContext.projectGraph);
    const ctProjectConfig = ctExecutorContext.projectGraph.nodes[ctExecutorContext.projectName].data;
    // angular only supports `tailwind.config.{js,cjs}`
    const ctProjectTailwindConfig = (0, path_1.join)(ctProjectConfig.root, 'tailwind.config');
    const isTailWindInCtProject = !!mappedGraph.allFiles[ctProjectTailwindConfig];
    const isTailWindInRoot = !!mappedGraph.allFiles['tailwind.config'];
    if (isTailWindInRoot || isTailWindInCtProject) {
        const pathToStyle = (0, ct_helpers_1.getTempTailwindPath)(ctExecutorContext);
        try {
            (0, fs_1.mkdirSync)((0, path_1.dirname)(pathToStyle), { recursive: true });
            (0, fs_1.writeFileSync)(pathToStyle, `
@tailwind base;
@tailwind components;
@tailwind utilities;
`, { encoding: 'utf-8' });
            return pathToStyle;
        }
        catch (makeTmpFileError) {
            devkit_1.logger.warn((0, devkit_1.stripIndents) `Issue creating a temp file for tailwind styles. Defaulting to no tailwind setup.
      Temp file path? ${pathToStyle}`);
            devkit_1.logger.error(makeTmpFileError);
        }
    }
}
//# sourceMappingURL=component-testing.js.map